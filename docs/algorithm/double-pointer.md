---
title: 双指针算法入门
date: 2021-06-17 15:04:30
categories: algorithm
---

## 双指针法原理

### 理解单指针

理解双指针之前，先说一下单指针。单指针就是说只有一个指针，这个指针是什么呢？

比如说我们遍历一个数组，那么每次遍历得到的索引或值对于这个数组来说，就是一个指针，指向已遍历的位置

```python
#!/usr/bin/env python
# --*--coding:utf-8--*--

l = [x for x in range(10)]
for i in l:
    # 这里的变量i，我们就可以理解为一个指针，指向遍历到列表l的位置
    # 为了后面讲解，这里我们就称它为索引指针吧
    print(i)
```



### 理解双指针

现在再理解双指针就容易一些了，还是以上面代码为例，双指针就是有两个指针，另一个指针指向哪里呢？

另一个指针也是指向列表的某个位置，具体如何操作则由我们手动通过代码来实现



一个数组，两个指针，看起来好像也不是很复杂嘛？

不是这样的，每个指针其实分为指针的索引和指针的值两种形式，这样说起来，是<span style="color: red;">1个数组和4个对象</span>，这一点非常重要！



<!-- more -->



### 双指针运用方式

下面说一下双指针该如何运用自如



根据两个指针运动的方向，可以分为

* 同向双指针，两个指针向同一个方向运动，可能是同向向右，也有可能是同向向左
* 反向双指针，两个指针分别由两端向另一端运动

简图示意

```bash
# 同向双指针
[ --->--------->--------- ]  数组
   指针B      指针A
或者
[ ---<---------<--------- ]  数组
   指针A      指针B

# 反向双指针
[ --->--------------<---- ]  数组
    指针A          指针B
或者
[ --------<---->--------- ]  数组
        指针A  指针B
```

> 本文`LeetCode`解题以<span style="color: red;">同向双指针</span>举例



根据两个指针的遍历次数，可以分为

* 一次遍历，一个指针遍历完成后，另一个指针不再遍历，然后程序结束
* 两次遍历，一个指针遍历完成后，另一个指针继续遍历，然后程序结束

> 一般来说一次遍历要比两次遍历性能高
>
> 本文`LeetCode`解题分别使用<span style="color: red;">一次遍历和两次遍历</span>举例



根据两个指针运动的速度，可以分为

* 快慢指针，一个运动快，一个运动慢
* 匀速指针，两个指针都以匀速运动

> 匀速指针的话，肯定不能是同向指针，否则这俩指针就重合为一个指针了，
>
> 或者说，<span style="color: red;">同向运动的指针 匀速运动和非匀速运动 要区分开</span>，这一点也很重要，否则就要掉坑了



根据两个指针操作的对象，可以得到

​	一个指针可以只操作索引，也可以只操作数据，还可以同时操作索引和数据，

​	也就是说一个指针可能有3种操作方式，那么两个指针就是<span style="color: red;">9种操作方式</span>，这点很重要！！！



## LeetCode 283.移动零

下面以`LeetCode`题目为例，讲解双指针的具体运用



### 题目描述



**题目地址**

​	https://leetcode-cn.com/problems/move-zeroes/

**题目描述**

​	给定一个数组 `nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例**

```bash
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**

​	1、<span style="color: red;">必须在原数组上操作，不能拷贝额外的数组。</span>
​	2、尽量减少操作次数。



### 暴力解题

先不管题目的附加要求，先把答案解出来，先降低要求，看能否解答，再提高要求解答

```python
#!/usr/bin/env python
# --*--coding:utf-8--*--


# 暴力解法-1
def t1(nums: list) -> list:
    ret1, ret2 = [], []
    for i in nums:
        ret1.append(i) if i != 0 else ret2.append(0)
    return ret1 + ret2


# 暴力解法-2
def t2(nums: list) -> list:
    return list(filter(lambda x: x != 0, nums)) + list(filter(lambda x: x == 0, nums))


# 暴力解法-3
def t3(nums: list) -> list:
    for i in nums.copy():
        if i == 0:
            nums.append(0)
            nums.remove(0)

    return nums


# 暴力解法N...
# ....


# 验证1
nums = [0, 1, 0, 3, 12]
print(t1(nums))  # [1, 3, 12, 0, 0]
print(t2(nums))  # [1, 3, 12, 0, 0]
print(t3(nums))  # [1, 3, 12, 0, 0]

# 验证2
l = [
    [],
    [0],
    [1, 1],
    [0, 0, 0, 1, 1, 1]
]
for i in l:
    print(t1(i))
    print(t2(i))
    print(t3(i))

# []
# []
# []
# [0]
# [0]
# [0]
# [1, 1]
# [1, 1]
# [1, 1]
# [1, 1, 1, 0, 0, 0]
# [1, 1, 1, 0, 0, 0]
# [1, 1, 1, 0, 0, 0]
```



### 满足题目要求解法1 - 两次遍历法

如果要满足题目，我们可以思考如何使用双指针如何来写



**确定两个指针的作用**

第一个指针肯定是索引指针，要完整的遍历完数组

第二个指针代表什么呢？其实我也不知道，那么我们就从其他方面反推一下



**确定两个指针运动方向**

索引指针肯定是从左向右遍历完整个数组，第二个指针呢？

看题目要求<span style="color: red;">同时保持非零元素的相对顺序</span>，这一点很重要！

如果第二个指针从右向左的话，这样一旦交换数据，元素顺序就会被打破，所以第二个指针只能从左向右



**再思考第二个指针的作用**

两个指针都是从左向右，那么第二个指针就代表 <span style="color: red;">符合题意的正确的数据</span>，题意要求的数据是

[非0元素1，非0元素2，....，0,0,0....]

一个指针不能既代表非0元素，又代表0元素，因为第二个指针和非0元素都在左边，所以第二个指针只能代表非0元素

完整的说法是：<span style="color: red;">第二个指针代表非0元素要插入的索引位置</span>，这里索引很重要！



**再看遍历次数**

索引指针运动完，第二个指针还要运动吗？

* 停止运动，那么当索引指针运动完，第二个指针后面的元素肯定已经都置为0了

* 继续运动，那么可以将第二个指针后面的元素都置为0，而不管他指向的值是什么，为什么？

  因为第二个指针操作的是索引，上面我们已经说过了

  

```python
#!/usr/bin/env python
# --*--coding:utf-8--*--

nums = [0, 1, 0, 3, 12]


def t1(nums: list) -> list:
    #  定义第二个指针，代表 非0元素要插入的索引位置
    j = 0

    # 遍历数组
    for i in nums:
        # 因为第二个指针要操作非0的数据，所以优先对非0数据进行判断
        if i != 0:
            nums[j] = i  # 非0数据插入到第二个指针索引的位置

            # 第二个指针有数据了，所以该向右移动一位了
            j += 1

            # 现在牵扯到 第二个指针要运动完 还是 第一个指针运动完 就让程序结束的问题了

    # 假设先让第二个指针运动完吧，那第二个指针后面的元素值应该都置为0
    for index in range(j, len(nums)):
        nums[index] = 0

    return nums


print(t1(nums))
# [1, 3, 12, 0, 0]

print(t1([]))
# []

print(t1([0]))
# [0]

print(t1([1, 1]))
# [1, 1]

print(t1([0, 0, 0, 1, 1, 1]))
# [1, 1, 1, 0, 0, 0]
```



### 双指针法流两次遍历动画演示

![283_1.gif](https://tuchuang-1257805459.cos.ap-shanghai.myqcloud.com/9669b4ffb158eaeeee6f0cd66a70f24411575edab1ab8a037c4c9084b1c743f5-283_1.gif)



### 满足题目要求解法2 - 一次遍历法

还是上面的代码，我们让第一个指针运动完程序就结束，第二个指针不再运动，看看能不能写出来

```python
#!/usr/bin/env python
# --*--coding:utf-8--*--

nums = [0, 1, 0, 3, 12]


def t1(nums: list) -> list:
    #  定义第二个指针，代表 非0元素要插入的索引位置
    j = 0

    # 遍历数组
    for index, i in enumerate(nums):
        # 因为第二个指针要操作非0的数据，所以优先对非0数据进行判断
        if i != 0:
            nums[j] = i  # 非0数据插入到第二个指针索引的位置

            # 第二个指针有数据了，所以该向右移动一位了
            j += 1

            # 现在牵扯到 第二个指针要运动完 还是 第一个指针运动完 就让程序结束的问题了
            # 这里让第一个指针运动完，程序就结束

            # 那么就要让第一个指针遍历要的值置为0
            # 所以就有如下代码
            # nums[index] = 0
            # 但是运行完脚本，发现问题，如果输入 [1, 1]，那么输出的是[0, 0]

            # 这个也很容易理解，试想一下，如果输入数据都是非0元素，那么两个指针的运动将重合
            # 也就是只有一个指针了，而且这个指针还把数据都置为0了，所以最后输出是 [0, 0]
            # 怎么解决呢？
            # 当他们运动不重合的时候，第一个指针指向的数据才置为0，所以代码如下
            if index != j - 1:
                nums[index] = 0
            # 这里j-1是因为j已经运动了一次，所以减去
            # 不然就是让 索引指针第一次运动的初始值（本次循环完会自动+1） 和 第二个指针第二次运动的初始值 做比较了

            # 总的来说，是挺绕的，需要仔细分析，加油，你就是最靓的仔!

    return nums


print(t1(nums))
# [1, 3, 12, 0, 0]

print(t1([]))
# []

print(t1([0]))
# [0]

print(t1([1, 1]))
# [1, 1]

print(t1([0, 0, 0, 1, 1, 1]))
# [1, 1, 1, 0, 0, 0]
```

> 上面的代码还可以优化一下，单纯是顺序上的优化，
>
> 将 `j+=1`与下面的`if`换下位置，`if`语句中的j就不用-1了



### 双指针法一次遍历动画演示

![36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2](https://tuchuang-1257805459.cos.ap-shanghai.myqcloud.com/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif)



## LeetCode 27.移除元素

`LeetCode`地址：https://leetcode-cn.com/problems/remove-element/

**题目描述**

给你一个数组 `nums `和一个值`val`，你需要 原地 移除所有数值等于`val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



**示例 1**

```bash
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]

解释：
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2**

```bash
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]

解释：
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```



**思路**

同向双指针，使用非`val`一路覆盖过去即可，这个套路要记熟



**题解**

```python
def moveEle(nums: list, val: int):
    # 指针j指向 准备要插入到列表中的索引
    j = 0

    # 遍历列表，每次遇到正确的值便替换为j索引的值
    for i in nums:
        if i != val:
            # 这一步是个套路，经常会用到，要记熟
            nums[j] = i
            j += 1

    # 返回j，这里并不需要+1，j索引当前值并非是正确的
    # nums[:j]用来验证我们的结果到底对不对
    return j, nums[:j]


print(moveEle([3, 2, 2, 3], 3))
# (2, [2, 2])
print(moveEle([0, 1, 2, 2, 3, 0, 4, 2], 2))
# (5, [0, 1, 3, 0, 4])
```

> 关键点：
>
> 指针方向：同向双指针，如果是反向双指针还需要考虑右指针的值是不是等于val
>
> 指针速度：双指针可以重合，不需要考虑一次还是两次遍历
>
>      if i != val:
>      	# 这一步是个套路，经常会用到，要记熟
>          nums[j] = i





## LeetCode 26.删除有序数组中的重复项

`LeetCode`地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

**题目描述**

给你一个有序数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成



**示例 1**

```bash
输入：nums = [1,1,2]
输出：2, nums = [1,2]

解释：
函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。
不需要考虑数组中超出新长度后面的元素。
```

**示例 2**

```bash
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]

解释：
函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。
不需要考虑数组中超出新长度后面的元素。
```



**思路**

<span style="color: red;">有序数组</span>是关键点，意味着我们可以使用同向双指针，可以保证第二个指针记录的值是唯一的

索引指针的值 与 j指针的值 做对比，不一样说明值不重复，然后 j指针向右移动一位，将索引指针的值赋值给j指针



**题解**

```python
def removeEle(nums: list):
    # 指针j指向 最后一次正确插入数据的索引，因为判断重复的话，要与当前值判断
    # 下次插入数据要从j+1位置插入
    j = 0

    # 遍历列表
    for i in nums:
        if i != nums[j]:
            j += 1
            nums[j] = i  # 这里的套路又用到了~
    return j + 1, nums[:j + 1]


print(removeEle([1, 1, 2]))
# (2, [1, 2])
print(removeEle([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]))
# (5, [0, 1, 2, 3, 4])
```

> 这个去重有点意思，圈起来，下次要考





## LeetCode 80. 删除有序数组中的重复项 II

题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/



**题目描述**

给你一个有序数组 `nums `，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成



**示例 1**

```bash
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]

解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
```



**示例 2**

```bash
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]

解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
```



**思路**

这个是上面题的升级版，不同的地方在于 `对出现次数 > 2  的数据去重`

还是原来的配方，在数据重复判断需要仔细想一下



j+1指针代表要插入的数据索引

对于j索引的值未重复的情况下，索引指针的值可以与j索引值重复

对于j索引的值已重复的情况下，索引指针的值不能与j索引值重复



**题解**

```python
def removeEle(nums: list):
    # 指针j指向 最后一次正确插入数据的索引,下次插入数据要从j+1位置插入
    j = 1

    # 遍历列表
    for i in nums[2:]:
        # j和j-1指向的值重复情况下
        # 索引指针的值 与 j或j-1的值 不一致时才允许插入
        if nums[j] == nums[j - 1]:
            if i != nums[j]:
                j += 1
                nums[j] = i
            continue

        # j和j-1指向的值不重复情况下
        # 任意值都可以插入到j的位置
        j += 1
        nums[j] = i

    # 为了严谨，这里判断一下数组元素个数
    # 如果数组小于等于2，直接返回
    # 这一步可以写到最前面，写到这也没事，只是多执行一步变量赋值j = 1,无影响
    if len(nums) <= 2:
        return len(nums), nums

    return j + 1, nums[:j + 1]

print(removeEle([1, 1, 1, 2, 2, 3]))
# (5, [1, 1, 2, 2, 3])

print(removeEle([0, 0, 1, 1, 1, 1, 2, 3, 3]))
# (7, [0, 0, 1, 1, 2, 3, 3])

print(removeEle([]))
# (0, [])

print(removeEle([1, 1]))
# (2, [1, 1])
```



也可以使用索引指针值与j和j-1进行判断，在我之前`LeetCode`的提交记录中是这样写的，可以参考一下

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        # j索引指向的值 为正确数据的值
        j = 1
        
        for i in nums[2:]: 
            # j为重复，索引指针跳过
            if i == nums[j] and nums[j] == nums[j-1]:
                continue
            
            # j为不重复
            if i == nums[j] and nums[j] != nums[j-1]:
                j += 1
                nums[j] = i
                continue
                        
            j += 1
            nums[j] = i
        
        # 没有写return，大意了!!!
        return j+1
```





## LeetCode 11. 盛最多水的容器

题目地址：https://leetcode-cn.com/problems/container-with-most-water/



**题目描述**

给你 n 个非负整数 `a1`，`a2`，`...`，`an`，每个数代表坐标中的一个点 `(i, ai)` 。

在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 `(i, ai)` 和 `(i, 0)` 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器



![image-20210629223117200](https://tuchuang-1257805459.cos.ap-shanghai.myqcloud.com/image-20210629223117200.png)

**示例1**

```bash
输入：[1,8,6,2,5,4,8,3,7]
输出：49 

解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2**

```bash
输入：height = [1,1]
输出：1
```

**示例 3**

```bash
输入：height = [4,3,2,1,4]
输出：16
```

**示例 4**

```bash
输入：height = [1,2,1]
输出：2
```



**思路**

先要看明白题意，最大面积的计算方法是：`（右边的索引 - 左边的索引）* 两个索引对应的值中最小的那一个`

反向双指针向中心位置移动，移动的条件是哪个指针对应的值小就移动哪个，直到两个指针重合

**题解**

```python
def maxArea(height: list):
    i, j = 0, len(height) - 1
    max_area = 0

    while i != j:
        _length = j - i
        _height = height[i] if height[i] < height[j] else height[j]  # 这要注意要求最小的高，很容易求反了~
        area = _length * _height
        max_area = area if area > max_area else max_area

        if height[i] <= height[j]:
            i += 1
        else:
            j -= 1
    return max_area


print(maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]))
# 49

print(maxArea([1, 1]))
# 1

print(maxArea([4, 3, 2, 1, 4]))
# 16

print(maxArea([1, 2, 1]))
# 2
```

下面这个是最开始写的带注释的，思路一样

```python
#!/usr/bin/env python
# --*--coding:utf-8--*--

def maxArea(height):
    # 左指针和右指针
    j, k = 0, len(height) - 1

    # 存贮最大的面积
    max_area = 0

    while j != k:
        # 求出最小的高
        if height[j] <= height[k]:
            min_height = height[j]
        else:
            min_height = height[k]

        # 求长
        width = k - j

        # 计算面积
        area = min_height * width
        if area > max_area:
            max_area = area

        # 指针移动
        if height[j] <= height[k]:
            j += 1
        else:
            k -= 1

    return max_area

print(maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]))
# 49
```

